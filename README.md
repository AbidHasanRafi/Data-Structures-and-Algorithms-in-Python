# ডেটা স্ট্রাকচার ও অ্যালগরিদম (পাইথন) 

### Table of Contents
- [অ্যালগরিদমিক অ্যানালাইসিস](#অ্যালগরিদমিক-অ্যানালাইসিস)
- [রিকার্শন](#রিকার্শন)
- [অ্যারে-বেসড সিকুয়েন্স](#অ্যারে-বেসড-সিকুয়েন্স)
- [স্ট্যাক, কিউ ও ডিকিউ](#স্ট্যাক-কিউ-ও-ডিকিউ)
- [লিংকড লিস্ট](#লিংকড-লিস্ট)
- [ট্রি](#ট্রি)
- [প্রায়োরিটি কিউ](#প্রায়োরিটি-কিউ)
- [ম্যাপ, হ্যাশ টেবিল ও স্কিপ লিস্ট](#ম্যাপ-হ্যাশ-টেবিল-ও-স্কিপ-লিস্ট)
- [সার্চ ট্রি](#সার্চ-ট্রি)
- [সর্টিং ও সিলেকশন](#সর্টিং-ও-সিলেকশন)
- [টেক্সট প্রসেসিং](#টেক্সট-প্রসেসিং)
- [গ্রাফ অ্যালগরিদম](#গ্রাফ-অ্যালগরিদম)
- [মেমোরি ম্যানেজমেন্ট ও বি-ট্রি](#মেমোরি-ম্যানেজমেন্ট-ও-বি-ট্রি)

## অ্যালগরিদমিক অ্যানালাইসিস
[![Header](assets/covers/1.svg "অ্যালগরিদমিক অ্যানালাইসিস")](https://abid-hasan-rafi.web.app/)

### Contents
- [এক্সপেরিমেন্টাল স্টাডিস](#এক্সপেরিমেন্টাল-স্টাডিস)
- [সাতটি ফাংশন](#সাতটি-ফাংশন)
- [অ্যাসিম্পটমিক অ্যানালাইসিস](#অ্যাসিম্পটমিক-অ্যানালাইসিস)
- [জাস্টিফিকেশন টেকনিক](#জাস্টিফিকেশন-টেকনিক)

### এক্সপেরিমেন্টাল স্টাডিস
এই সম্পূর্ণ আলোচনায় কিভাবে `ভালো` 'ডেটা স্ট্রাকচার ও অ্যালগরিদম' ডিজাইন করা যায় তা নিয়ে আলোচনা করা হবে। প্রথমে বুঝতে হবে ডেটা স্ট্রাকচার ও অ্যালগরিদম আসলে কি? ডেটা স্ট্রাকচার বলতে সিস্টেমিকভাবে ডেটাকে অর্গানাইজ বা এক্সেস করার পদ্ধতিকে বুঝানো হয় এবং সীমিত সময়ের মধ্যে এক বা একাধিক ধারাবাহিক প্রক্রিয়ার মাধ্যমে কিছু কাজ সম্পন্ন করাকে অ্যালগরিদম বলা হয়। এই কন্সেপ্টগুলো কম্পিউটিং কেন্দ্রিক কিন্তু কিছু ডেটা স্ট্রাকচার ও অ্যালগরিদমকে `ভালো` হিসেবে সঠিকভাবে ক্লাসিফাই করতে এদের যথাযথ বিশ্লেষণ সম্পর্কে আমাদের ধারণা রাখা প্রয়োজন। অ্যালগরিদম ও ডেটা স্ট্রাকচারের প্রাথমিক এনালাইসিস টুল হিসেবে আমরা 'রানিং টাইম' এবং 'স্পেস (মেমোরি) ইউজয়েজ' এর বৈশিষ্ট্য বিশ্লেষণের মাধ্যমে আলোচনা করবো।

কোনো অ্যালগরিদম ইমপ্লিমেন্ট করার পর বিভিন্ন টেস্ট কেস-এ এগুলো এক্সিকিউট করে রানিং টাইম পর্যবেক্ষণ করার যায়। পাইথনে এটি করার একটি সহজ উপায় হলো `time module` থেকে `time` ফাংশন ব্যবহার করাঃ

```python
from time import time
start_time = time.time()  # Record the starting time
# Run the algorithm here
end_time = time.time()    # Record the ending time
elapsed_time = end_time - start_time  # Compute the elapsed time
```
এখানে, একটি অ্যালগরিদমের রানিং টাইম সম্পর্কিত পরীক্ষামূলক গবেষণায় (n, t) স্থানাঙ্ক বিশিষ্ট একাধিক বিন্দু বিশিষ্ট একটি গ্রাফচিত্র দেখানো হলো যেখানে n আকারের ইনপুটের জন্য অ্যালগোরিদমটির রানিং টাইম t মিলিসেকেন্ড (ms) হিসাবে পরিমাপ করা হয়েছে।

![Figure 1.1](assets/chapter%2001/fig%201.1.svg "Figure 1.1")

ফাইনটিউন করা প্রোডাকশন কোয়ালিটি কোডের জন্য রানিং টাইমের এক্সপেরিমেন্ট অনেক গুরুত্বপূর্ণ, তবে এখানে তিনটি বিশেষ সীমাবদ্ধতা রয়েছেঃ
- দুটি অ্যালগরিদমের পরীক্ষামূলক রানিং টাইম ফলাফল সরাসরি তুলনা করা কঠিন, যদি না এক্সপেরিমেন্টটি একই হার্ডওয়ার এবং সফ্টওয়্যার এনভায়ারমেন্টে করা হয়।
- এক্সপেরিমেন্টগুলো কেবলমাত্র সীমিত সংখ্যক টেস্ট ইনপুটের উপর করা যায়; ফলে, এক্সপেরিমেন্টের অন্তর্ভুক্ত নয় এমন অনেক ইনপুটের রানিং টাইম চূড়ান্ত বিবেচনায় আসে না।
- একটি অ্যালগরিদমের রানিং টাইম পরীক্ষামূলকভাবে স্টাডি করার জন্য এটি সম্পূর্ণরূপে এক্সিকিউট হতে হয়।

আমাদের লক্ষ্য হল এমন পদ্ধতি ডেভেলপ করা যা অ্যালগরিদমের দক্ষতা বিশ্লেষণ করতে পারে এবং কতিপয় কিছু বৈশিষ্ট্যসমূহ ধারণ করেঃ
- যেকোনো দুটি অ্যালগরিদমের আপেক্ষিক দক্ষতা তুলনা করতে পারে, যা হার্ডওয়ার ও সফ্টওয়্যার এনভায়ারমেন্টের উপর নির্ভরশীল নয়।
- ইমপ্লিমেন্ট ছাড়াই অ্যালগোরিদমের হাই-লেভেল বর্ণনা স্টাডি করে দক্ষতা বিশ্লেষণ করা যায়।
- এক্সপেরিমেন্টের সম্ভাব্য সকল ইনপুট বিবেচনা করে।

কোনো এক্সপেরিমেন্ট করা ছাড়াই অ্যালগরিদমের রানিং টাইম পর্যবেক্ষণ করতে আমরা সরাসরি অ্যালগরিদমটির হাই-লেভেল বর্ণনার উপর পরীক্ষামূলক এক্সপেরিমেন্ট করি। আমরা কিছু `প্রিমিটিভ অপারেশন` (ধ্রুবক রানিং টাইম বিশিষ্ট লো-লেভেল ইন্সট্রাকশন) ডিফাইন করে এগুলো করতে পারিঃ
- একটি `identifier` -কে একটি `object` এ এসাইন করা
- `identifier` এর সাথে সম্পৃক্ত `object` -কে শণাক্ত করা
- একটি অ্যালগরিদমিক অপারেশন চালানো
- দুটি সংখ্যাকে তুলনা করা
- ইনডেক্সের মাধ্যমে পাইথনের কোনো `list` থেকে যেকোনো একটি এলিমেন্টকে এক্সেস করা
- ফাংশন কল করা
- ফাংশন থেকে কিছু রিটার্ন করা

অ্যালগরিদমে প্রিমিটিভ অপারেশনগুলো কতিপয় অ্যালগরিদমের রানিং টাইমের সমানুপাতিক হয়ে থাকে। অ্যালগরিদমের রানিং টাইমের বৃদ্ধির ধারা বোঝার জন্য, আমরা প্রতিটি অ্যালগরিদমের সাথে একটি ফাংশন f(n) সংযুক্ত করব যেখানে n দ্বারা ফাংশনের নির্বাহিত প্রিমিটিভ অপারেশনের সংখ্যাকে বর্ণনা করা হয়। একই সংখ্যক ইনপুট হলেও নির্দিষ্ট ইনপুটের উপর নির্ভর করে একটি অ্যালগরিদমের রানিং টাইম উল্লেখযোগ্যভাবে পরিবর্তিত হতে পারে। এই পরিবর্তন বুঝতে, সেই সংখ্যক সম্ভাব্য সকল ইনপুটের গড় (average-case) রানিং টাইম বিশ্লেষণ করা করতে হবে। তবে, এধরনের বিশ্লেষণ করা খানিকটা কঠিন, কারণ এখানে সকল ইনপুটের জন্য প্রবাবিলিটি ডিস্ট্রিবিউশন (সম্ভাব্যতা বণ্টন) নির্ধারণের প্রয়োজন পড়ে। একটি অ্যালগরিদমের বিভিন্ন সম্ভাব্য ইনপুটের জন্য রানিং টাইমকে প্রতিনিধিত্ব করে `best-case` এবং `worst-case` এর রানিং টাইমের একটি তুলনামূলক গ্রাফচিত্র নিচে দেখানো হলোঃ

![Figure 1.2](assets/chapter%2001/fig%201.2.svg "Figure 1.2")

### সাতটি ফাংশন

### অ্যাসিম্পটমিক অ্যানালাইসিস

### জাস্টিফিকেশন টেকনিক

## রিকার্শন
[![Header](assets/covers/2.svg "রিকার্শন")](https://abid-hasan-rafi.web.app/)

## অ্যারে-বেসড সিকুয়েন্স
[![Header](assets/covers/3.svg "অ্যারে-বেসড সিকুয়েন্স")](https://abid-hasan-rafi.web.app/)

## স্ট্যাক, কিউ ও ডিকিউ
[![Header](assets/covers/4.svg "স্ট্যাক, কিউ ও ডিকিউ")](https://abid-hasan-rafi.web.app/)

## লিংকড লিস্ট
[![Header](assets/covers/5.svg "লিংকড লিস্ট")](https://abid-hasan-rafi.web.app/)

## ট্রি
[![Header](assets/covers/6.svg "ট্রি")](https://abid-hasan-rafi.web.app/)

## প্রায়োরিটি কিউ
[![Header](assets/covers/7.svg "প্রায়োরিটি কিউ")](https://abid-hasan-rafi.web.app/)

## ম্যাপ, হ্যাশ টেবিল ও স্কিপ লিস্ট
[![Header](assets/covers/8.svg "ম্যাপ, হ্যাশ টেবিল ও স্কিপ লিস্ট")](https://abid-hasan-rafi.web.app/)

## সার্চ ট্রি
[![Header](assets/covers/9.svg "সার্চ ট্রি")](https://abid-hasan-rafi.web.app/)

## সর্টিং ও সিলেকশন
[![Header](assets/covers/10.svg "সর্টিং ও সিলেকশন")](https://abid-hasan-rafi.web.app/)

## টেক্সট প্রসেসিং
[![Header](assets/covers/11.svg "টেক্সট প্রসেসিং")](https://abid-hasan-rafi.web.app/)

## গ্রাফ অ্যালগরিদম
[![Header](assets/covers/12.svg "গ্রাফ অ্যালগরিদম")](https://abid-hasan-rafi.web.app/)

## মেমোরি ম্যানেজমেন্ট ও বি-ট্রি
[![Header](assets/covers/13.svg "মেমোরি ম্যানেজমেন্ট ও বি-ট্রি")](https://abid-hasan-rafi.web.app/)

